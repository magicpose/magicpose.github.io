{"meta":{"title":"Pivot's Blog","subtitle":"blog.magicpose.com","description":"善人同处，则日闻嘉训；恶人从游，则日生邪情","author":"潇威","url":"http://blog.magicpose.com"},"pages":[{"title":"Categories","date":"2017-09-21T09:44:21.232Z","updated":"2017-09-21T09:44:21.232Z","comments":false,"path":"categories/index.html","permalink":"http://blog.magicpose.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-09-21T09:44:52.889Z","updated":"2017-09-21T09:44:52.889Z","comments":true,"path":"tags/index.html","permalink":"http://blog.magicpose.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-09-20T10:08:34.000Z","updated":"2017-10-25T09:09:17.558Z","comments":false,"path":"about/index.html","permalink":"http://blog.magicpose.com/about/index.html","excerpt":"","text":"联系方式: xwpivot@gmail.com"}],"posts":[{"title":"Java jstack 用法","slug":"jvm/reprint_jstack","date":"2017-11-16T03:56:13.318Z","updated":"2017-11-16T10:40:37.060Z","comments":true,"path":"2017/11/16/jvm/reprint_jstack/","link":"","permalink":"http://blog.magicpose.com/2017/11/16/jvm/reprint_jstack/","excerpt":"","text":"应用开发笔记 jstack是jdk中自带的用于查看进程内线程栈的工具。当程序出现死锁时，我们可以通过jstack打印线程栈找到问题。 找出代码中的死锁学习从一段简单的代码开始:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Main &#123; public static void main(String[] args) &#123; test1(); &#125; private static void test1() &#123; final Object lock1 = new Object(); final Object lock2 = new Object(); Thread thread=new Thread(new Runnable() &#123; public void run() &#123; synchronized (lock1) &#123; try &#123; for(int i=0;i&lt;20;i++) &#123; Thread.sleep(1000); System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); &#125; synchronized (lock2) &#123; for(int i=20;i&lt;40;i++) &#123; Thread.sleep(1000); System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); thread.start(); synchronized (lock2) &#123; try &#123; for(int i=0;i&lt;20;i++) &#123; Thread.sleep(1000); System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); &#125; synchronized (lock1) &#123; for(int i=20;i&lt;40;i++) &#123; Thread.sleep(1000); System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 肉眼都能看出来的死锁，程序运行20s后进入死锁状态。首先我们先找出这个程序的进程id,建议用jps,而不是ps,原因是jps只会显示当前用户下面的java进程，等于自动帮我们过滤了。1234567jps -l$ jps8896 Bootstrap3941 Bootstrap11718 Jps9711 Bootstrap jstack 显示堆栈信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120$ jstack 97112017-05-23 13:57:22Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.45-b02 mixed mode):&quot;Attach Listener&quot; #12 daemon prio=9 os_prio=31 tid=0x00007ff0f780c800 nid=0x4507 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;Thread-0&quot; #11 prio=5 os_prio=31 tid=0x00007ff0f80c0000 nid=0x5a03 waiting for monitor entry [0x0000700002310000] java.lang.Thread.State: BLOCKED (on object monitor) at Main$1.run(Main.java:33) - waiting to lock &lt;0x000000076adb1a98&gt; (a java.lang.Object) - locked &lt;0x000000076adb1a88&gt; (a java.lang.Object) at java.lang.Thread.run(Thread.java:745)&quot;Service Thread&quot; #10 daemon prio=9 os_prio=31 tid=0x00007ff0f980b800 nid=0x5603 runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;C1 CompilerThread3&quot; #9 daemon prio=9 os_prio=31 tid=0x00007ff0f6803000 nid=0x5403 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;C2 CompilerThread2&quot; #8 daemon prio=9 os_prio=31 tid=0x00007ff0f6802800 nid=0x5203 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;C2 CompilerThread1&quot; #7 daemon prio=9 os_prio=31 tid=0x00007ff0f6801800 nid=0x5003 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;C2 CompilerThread0&quot; #6 daemon prio=9 os_prio=31 tid=0x00007ff0f90de800 nid=0x4e03 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;Monitor Ctrl-Break&quot; #5 daemon prio=5 os_prio=31 tid=0x00007ff0f90dc800 nid=0x4c03 runnable [0x0000700001bfb000] java.lang.Thread.State: RUNNABLE at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) at java.net.SocketInputStream.read(SocketInputStream.java:170) at java.net.SocketInputStream.read(SocketInputStream.java:141) at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284) at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178) - locked &lt;0x000000076af12b68&gt; (a java.io.InputStreamReader) at java.io.InputStreamReader.read(InputStreamReader.java:184) at java.io.BufferedReader.fill(BufferedReader.java:161) at java.io.BufferedReader.readLine(BufferedReader.java:324) - locked &lt;0x000000076af12b68&gt; (a java.io.InputStreamReader) at java.io.BufferedReader.readLine(BufferedReader.java:389) at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:64)&quot;Signal Dispatcher&quot; #4 daemon prio=9 os_prio=31 tid=0x00007ff0f8039800 nid=0x4a03 runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;Finalizer&quot; #3 daemon prio=8 os_prio=31 tid=0x00007ff0f9803000 nid=0x3903 in Object.wait() [0x0000700001972000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x000000076ab06f58&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143) - locked &lt;0x000000076ab06f58&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164) at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=31 tid=0x00007ff0f9802000 nid=0x3703 in Object.wait() [0x000070000186f000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x000000076ab06998&gt; (a java.lang.ref.Reference$Lock) at java.lang.Object.wait(Object.java:502) at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:157) - locked &lt;0x000000076ab06998&gt; (a java.lang.ref.Reference$Lock)&quot;main&quot; #1 prio=5 os_prio=31 tid=0x00007ff0f8002000 nid=0x1c03 waiting for monitor entry [0x0000700000e51000] java.lang.Thread.State: BLOCKED (on object monitor) at Main.test1(Main.java:52) - waiting to lock &lt;0x000000076adb1a88&gt; (a java.lang.Object) - locked &lt;0x000000076adb1a98&gt; (a java.lang.Object) at Main.main(Main.java:18)&quot;VM Thread&quot; os_prio=31 tid=0x00007ff0f801f800 nid=0x3503 runnable&quot;GC task thread#0 (ParallelGC)&quot; os_prio=31 tid=0x00007ff0f9003800 nid=0x2503 runnable&quot;GC task thread#1 (ParallelGC)&quot; os_prio=31 tid=0x00007ff0f9004000 nid=0x2703 runnable&quot;GC task thread#2 (ParallelGC)&quot; os_prio=31 tid=0x00007ff0f7801000 nid=0x2903 runnable&quot;GC task thread#3 (ParallelGC)&quot; os_prio=31 tid=0x00007ff0f600e800 nid=0x2b03 runnable&quot;GC task thread#4 (ParallelGC)&quot; os_prio=31 tid=0x00007ff0f600f000 nid=0x2d03 runnable&quot;GC task thread#5 (ParallelGC)&quot; os_prio=31 tid=0x00007ff0f6010000 nid=0x2f03 runnable&quot;GC task thread#6 (ParallelGC)&quot; os_prio=31 tid=0x00007ff0f6010800 nid=0x3103 runnable&quot;GC task thread#7 (ParallelGC)&quot; os_prio=31 tid=0x00007ff0f6011000 nid=0x3303 runnable&quot;VM Periodic Task Thread&quot; os_prio=31 tid=0x00007ff0f980c000 nid=0x5803 waiting on conditionJNI global references: 26Found one Java-level deadlock:=============================&quot;Thread-0&quot;: waiting to lock monitor 0x00007ff0f8024f38 (object 0x000000076adb1a98, a java.lang.Object), which is held by &quot;main&quot;&quot;main&quot;: waiting to lock monitor 0x00007ff0f8023bf8 (object 0x000000076adb1a88, a java.lang.Object), which is held by &quot;Thread-0&quot;Java stack information for the threads listed above:===================================================&quot;Thread-0&quot;: at Main$1.run(Main.java:33) - waiting to lock &lt;0x000000076adb1a98&gt; (a java.lang.Object) - locked &lt;0x000000076adb1a88&gt; (a java.lang.Object) at java.lang.Thread.run(Thread.java:745)&quot;main&quot;: at Main.test1(Main.java:52) - waiting to lock &lt;0x000000076adb1a88&gt; (a java.lang.Object) - locked &lt;0x000000076adb1a98&gt; (a java.lang.Object) at Main.main(Main.java:18)Found 1 deadlock. jstack直接帮我们找出来了deadlock。真实场景下，如果代码比较复杂，可能需要我们自己分析找出死锁。如果我们自己分析，该怎么找出死锁呢？重点分析java.lang.Thread.State: BLOCKED的进程，找到waiting to lock，看看这个锁的持有者，是不是也被锁着，沿着这个链路找下去，是不是死锁就能找出来 了。比如上面的例子中,main线程持有0x000000076adb1a98锁，等待0x000000076adb1a88锁释放，而Thread-0持有0x000000076adb1a88锁，等待0x000000076adb1a98锁释放，两个线程互相等待，而进入死锁状态。 找出CPU消耗多的代码如果程序cpu占用很高，我们需要找到问题优化，可以配合top命令，找出最耗cpu的进程，从而找到相应代码解决问题。 先用jps找出程序pid，这里是23034 用top命令找出该进程最耗cpu的线程。下面的top是linux中的，mac里的不一样。 top -Hp 9711 查看占用CPU较高的PID,并将其转化为16进制因为top里的pid是10进制，而jstack里是16进制，叫nid。可以用printf命令转换 printf &quot;%x\\n&quot; &lt;pid&gt; 得到16进制PID jstack出场 jstack 23034 | grep 16进制PID 查看并分析结果找出问题","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://blog.magicpose.com/tags/JVM/"}]},{"title":"专业名词解释 1","slug":"English/directory","date":"2017-11-13T03:16:25.043Z","updated":"2017-11-13T03:17:34.607Z","comments":true,"path":"2017/11/13/English/directory/","link":"","permalink":"http://blog.magicpose.com/2017/11/13/English/directory/","excerpt":"","text":"网站访问量DAU: Daily Active User 日活跃用户 UV: Unique Visitor 独立游客","categories":[],"tags":[{"name":"English","slug":"English","permalink":"http://blog.magicpose.com/tags/English/"}]},{"title":"H2 数据库安装","slug":"h2/install h2","date":"2017-11-11T10:00:11.484Z","updated":"2017-11-11T10:29:40.060Z","comments":true,"path":"2017/11/11/h2/install h2/","link":"","permalink":"http://blog.magicpose.com/2017/11/11/h2/install h2/","excerpt":"","text":"安装H2官方站点 安装JAVA环境,设置JAVA_HOME,CLASSPATH下载安装不多说12345678910# linux下设置java环境变量vim /etc/profileexport JAVA_HOME=/opt/java/jdk1.8.0_151export JAVA_BIN=$JAVA_HOME/binexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$JAVA_HOME/bin:$PATH# 使设置生效source /etc/profile Windows下载H2压缩包,解压,进入目录,build.bat123cd bin# 运行 h2.bath2.bat Linux下载H2压缩包,解压,进入目录,./build.sh123cd bin# 运行 h2.sh &amp;./h2.sh &amp; 启动配置 .h2.server.properties默认启动只允许本机访问,需要设置一个属性webAllowOthers=true.这个在windows下面启动之后有个配置页面可以进行配置 Linux下因为没有安装GUI,所以很恶心,启动后无法访问,访问提示&quot;Sorry, remote connections (&#39;webAllowOthers&#39;) are disabled on this server&quot; 那么注意重点,方法来了:在Windows下配置后,会生成一个属性文件.h2.server.properties,文件位置在&quot;C:\\Users\\用户目录&quot;,打开该文件可以看到12345678910111213141516171819202122#H2 Server Properties#Sat Nov 11 17:40:03 CST 20170=Generic JNDI Data Source|javax.naming.InitialContext|java\\:comp/env/jdbc/Test|sa1=Generic Firebird Server|org.firebirdsql.jdbc.FBDriver|jdbc\\:firebirdsql\\:localhost\\:/temp/firebird/test|sysdba10=Generic Derby (Server)|org.apache.derby.jdbc.ClientDriver|jdbc\\:derby\\://localhost\\:1527/test;create\\=true|sa11=Generic Derby (Embedded)|org.apache.derby.jdbc.EmbeddedDriver|jdbc\\:derby\\:test;create\\=true|sa12=Generic H2 (Server)|org.h2.Driver|jdbc\\:h2\\:tcp\\://localhost/~/test|sa# 注意此处默认有一个test数据库,数据库位置&quot;d:/opt/h2/data/test&quot;,用户名是test. 如果要移植到Linux下的时候将此处目录修改为在Linux上对应目录即可13=Generic H2 (Embedded)|org.h2.Driver|jdbc\\:h2\\:d\\:/opt/h2/data/test|test2=Generic SQLite|org.sqlite.JDBC|jdbc\\:sqlite\\:test|sa3=Generic DB2|com.ibm.db2.jcc.DB2Driver|jdbc\\:db2\\://localhost/test|4=Generic Oracle|oracle.jdbc.driver.OracleDriver|jdbc\\:oracle\\:thin\\:@localhost\\:1521\\:XE|sa5=Generic MS SQL Server 2000|com.microsoft.jdbc.sqlserver.SQLServerDriver|jdbc\\:microsoft\\:sqlserver\\://localhost\\:1433;DatabaseName\\=sqlexpress|sa6=Generic MS SQL Server 2005|com.microsoft.sqlserver.jdbc.SQLServerDriver|jdbc\\:sqlserver\\://localhost;DatabaseName\\=test|sa7=Generic PostgreSQL|org.postgresql.Driver|jdbc\\:postgresql\\:test|8=Generic MySQL|com.mysql.jdbc.Driver|jdbc\\:mysql\\://localhost\\:3306/test|9=Generic HSQLDB|org.hsqldb.jdbcDriver|jdbc\\:hsqldb\\:test;hsqldb.default_table_type\\=cached|sa# 允许远程访问webAllowOthers=true# 访问端口webPort=80webSSL=false 将.h2.server.properties文件移植到Linux系统下,如果是root,则放在/root目录下即可,其他用户放到/home/用户目录下(没测试过)12345678910111213141516171819#H2 Server Properties#Sat Nov 11 17:58:34 CST 20170=Generic JNDI Data Source|javax.naming.InitialContext|java\\:comp/env/jdbc/Test|sa1=Generic Firebird Server|org.firebirdsql.jdbc.FBDriver|jdbc\\:firebirdsql\\:localhost\\:/temp/firebird/test|sysdba10=Generic Derby (Server)|org.apache.derby.jdbc.ClientDriver|jdbc\\:derby\\://localhost\\:1527/test;create\\=true|sa11=Generic Derby (Embedded)|org.apache.derby.jdbc.EmbeddedDriver|jdbc\\:derby\\:test;create\\=true|sa12=Generic H2 (Server)|org.h2.Driver|jdbc\\:h2\\:tcp\\://localhost/~/test|sa13=Generic H2 (Embedded)|org.h2.Driver|jdbc\\:h2\\:/opt/h2/data/xxx|xxx2=Generic SQLite|org.sqlite.JDBC|jdbc\\:sqlite\\:test|sa3=Generic DB2|com.ibm.db2.jcc.DB2Driver|jdbc\\:db2\\://localhost/test|4=Generic Oracle|oracle.jdbc.driver.OracleDriver|jdbc\\:oracle\\:thin\\:@localhost\\:1521\\:XE|sa5=Generic MS SQL Server 2000|com.microsoft.jdbc.sqlserver.SQLServerDriver|jdbc\\:microsoft\\:sqlserver\\://localhost\\:1433;DatabaseName\\=sqlexpress|sa6=Generic MS SQL Server 2005|com.microsoft.sqlserver.jdbc.SQLServerDriver|jdbc\\:sqlserver\\://localhost;DatabaseName\\=test|sa7=Generic PostgreSQL|org.postgresql.Driver|jdbc\\:postgresql\\:test|8=Generic MySQL|com.mysql.jdbc.Driver|jdbc\\:mysql\\://localhost\\:3306/test|9=Generic HSQLDB|org.hsqldb.jdbcDriver|jdbc\\:hsqldb\\:test;hsqldb.default_table_type\\=cached|sawebAllowOthers=truewebPort=80webSSL=false","categories":[],"tags":[{"name":"h2","slug":"h2","permalink":"http://blog.magicpose.com/tags/h2/"}]},{"title":"GitBook Read","slug":"gitbook/directory","date":"2017-11-10T01:32:49.868Z","updated":"2017-11-10T01:34:18.321Z","comments":true,"path":"2017/11/10/gitbook/directory/","link":"","permalink":"http://blog.magicpose.com/2017/11/10/gitbook/directory/","excerpt":"","text":"##","categories":[],"tags":[{"name":"GitBook","slug":"GitBook","permalink":"http://blog.magicpose.com/tags/GitBook/"}]},{"title":"这一天天的吃食","slug":"eat/menu","date":"2017-10-25T10:00:09.696Z","updated":"2017-10-26T07:43:51.455Z","comments":true,"path":"2017/10/25/eat/menu/","link":"","permalink":"http://blog.magicpose.com/2017/10/25/eat/menu/","excerpt":"","text":"2017年10月25日好豆-炖豆腐 好豆-宫保鸡","categories":[],"tags":[{"name":"eat","slug":"eat","permalink":"http://blog.magicpose.com/tags/eat/"}]},{"title":"经济学理论","slug":"life/economic","date":"2017-10-25T05:42:54.857Z","updated":"2017-10-26T07:43:47.480Z","comments":true,"path":"2017/10/25/life/economic/","link":"","permalink":"http://blog.magicpose.com/2017/10/25/life/economic/","excerpt":"","text":"菜单成本商家涨价的时候也得花钱.餐厅该价格要重印菜单,重做宣传,安抚抗议的消费者 古诺均衡通俗来讲，一种产品市场只有两个卖家，卖的东西基本无差别，两个卖家相互之间也没有任何串通行为,不过都知道对方将生产多少、怎样定价，这样，双方都可以确定最优的产量来实现利润最大化。在这种均衡之下,低价格和微薄的利润，将大部分竞争对手阻挡在行业之外，而少数的巨头则依赖于规模生存下来，获得尚属可观的总量利润。 知乎:为什么可口可乐涨价幅度不大？","categories":[{"name":"经济","slug":"经济","permalink":"http://blog.magicpose.com/categories/经济/"}],"tags":[{"name":"economic","slug":"economic","permalink":"http://blog.magicpose.com/tags/economic/"}]},{"title":"MYSQL按时间统计","slug":"mysql_datetime_count","date":"2017-10-01T14:22:27.899Z","updated":"2017-10-01T14:25:57.462Z","comments":true,"path":"2017/10/01/mysql_datetime_count/","link":"","permalink":"http://blog.magicpose.com/2017/10/01/mysql_datetime_count/","excerpt":"","text":"以下例子是按照小时和按照日期统计,其他的姿势可以自行切换12345678# 按小时统计SELECT DATE_FORMAT(create_time, &apos;%Y-%m-%d %H&apos;) &apos;月份&apos;,COUNT(*) &apos;出库单数量&apos; FROM erp_warehouse_out WHERE DATE_FORMAT(create_time,&apos;%Y-%m-%d&apos;)=&apos;2017-10-01&apos; GROUP BY DATE_FORMAT(create_time, &apos;%Y-%m-%d %H&apos;); # 按日期统计SELECT DATE_FORMAT(create_time, &apos;%Y-%m-%d&apos;) &apos;月份&apos;,COUNT(*) &apos;出库单数量&apos; FROM erp_warehouse_in WHERE create_time&gt;&apos;2017-10-01 01:00:00&apos; GROUP BY DATE_FORMAT(create_time, &apos;%Y-%m-%d&apos;);","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://blog.magicpose.com/categories/MYSQL/"}],"tags":[]},{"title":"redis-cli 查看redis性能信息","slug":"redis-info","date":"2017-09-26T07:37:36.037Z","updated":"2017-09-27T01:29:02.886Z","comments":true,"path":"2017/09/26/redis-info/","link":"","permalink":"http://blog.magicpose.com/2017/09/26/redis-info/","excerpt":"","text":"info123456789101112131415$ redis-cli -h 127.0.0.1 -p 4848 -a 'pwd' info | grep -e \"connected_clients\" -e \"blocked_clients\" -e \"used_memory_human\" -e \"used_memory_peak_human\" -e \"rejected_connections\" -e \"evicted_keys\" -e \"instantaneous\"connected_clients:203blocked_clients:0used_memory_human:1.45Gused_memory_peak_human:1.89Ginstantaneous_ops_per_sec:2029instantaneous_input_kbps:1646.20instantaneous_output_kbps:2149.47rejected_connections:0evicted_keys:0","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://blog.magicpose.com/tags/redis/"}]},{"title":"GC overhead limit","slug":"java_exception_gc_overhead","date":"2017-09-24T04:14:56.780Z","updated":"2017-09-24T04:17:07.573Z","comments":true,"path":"2017/09/24/java_exception_gc_overhead/","link":"","permalink":"http://blog.magicpose.com/2017/09/24/java_exception_gc_overhead/","excerpt":"","text":"问题描述导出excel的时候报错. 异常代码摘要12345678910111213141516171819202122org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun java.lang.OutOfMemoryError: GC overhead limit exceeded at org.apache.xmlbeans.impl.store.Saver$SynthNamespaceSaver.&lt;init&gt;(Saver.java:863) at org.apache.xmlbeans.impl.store.Saver.&lt;init&gt;(Saver.java:121) at org.apache.xmlbeans.impl.store.Saver$TextSaver.&lt;init&gt;(Saver.java:896) at org.apache.xmlbeans.impl.store.Cursor._xmlText(Cursor.java:546) at org.apache.xmlbeans.impl.store.Cursor.xmlText(Cursor.java:2436) at org.apache.xmlbeans.impl.values.XmlObjectBase.xmlText(XmlObjectBase.java:1455) at org.apache.poi.xssf.model.SharedStringsTable.getKey(SharedStringsTable.java:130) at org.apache.poi.xssf.model.SharedStringsTable.addEntry(SharedStringsTable.java:176) at org.apache.poi.xssf.usermodel.XSSFCell.setCellValue(XSSFCell.java:345) at org.apache.poi.xssf.usermodel.XSSFCell.setCellValue(XSSFCell.java:315) at com.jfinal.ext.kit.excel.PoiExporter.processAsRecord(PoiExporter.java:199) at com.jfinal.ext.kit.excel.PoiExporter.export(PoiExporter.java:135) at com.jfinal.ext.render.excel.PoiRender.render(PoiRender.java:57) at com.jfinal.core.ActionHandler.handle(ActionHandler.java:99) at org.edaw.report.common.handler.SessionHandler.handle(SessionHandler.java:30) at com.jfinal.core.JFinalFilter.doFilter(JFinalFilter.java:74) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:212) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:94) 原因和解决方案jdk的一种预警,表示gc可能发生内存溢出.可修改jdk参数尝试修复 1234567891011# 修改 catalina.sh 启动参数JAVA_OPTS=\"-server-Xms6144m-Xms6144m-XX:MaxPermSize=1024m -XX:MetaspaceSize=512m-XX:+UseG1GC-XX:ParallelGCThreads=6-XX:NewRatio=2 -XX:ConcGCThreads=4-XX:MaxGCPauseMillis=300-XX:InitiatingHeapOccupancyPercent=50 -XX:G1HeapRegionSize=4m -XX:+ExplicitGCInvokesConcurrent-XX:+PrintGCDetails -Xloggc:/mnt/wwwroot/server/tomcat/gclog/report_tomcat_gc.log\"","categories":[{"name":"JAVA","slug":"djava","permalink":"http://blog.magicpose.com/categories/djava/"}],"tags":[]},{"title":"first","slug":"first","date":"2017-09-21T07:01:54.000Z","updated":"2017-09-21T12:51:06.816Z","comments":true,"path":"2017/09/21/first/","link":"","permalink":"http://blog.magicpose.com/2017/09/21/first/","excerpt":"","text":"1$ hexo new \"My New Post\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.","categories":[{"name":"测试","slug":"test","permalink":"http://blog.magicpose.com/categories/test/"}],"tags":[{"name":"edaw","slug":"edaw","permalink":"http://blog.magicpose.com/tags/edaw/"},{"name":"test","slug":"test","permalink":"http://blog.magicpose.com/tags/test/"},{"name":"uec","slug":"uec","permalink":"http://blog.magicpose.com/tags/uec/"}]},{"title":"安装Hexo","slug":"hexo","date":"2017-09-20T11:25:32.829Z","updated":"2017-09-24T08:16:34.940Z","comments":true,"path":"2017/09/20/hexo/","link":"","permalink":"http://blog.magicpose.com/2017/09/20/hexo/","excerpt":"","text":"安装清单 安装 node.js 安装 git 安装 hexo 安装 Node.jsNode.js 一路安装即可,没什么需要注意的cmd-npm -v 查看安装结果 安装 gitwindow下一般安装 msysgit 一路安装即可 安装 Hexo使用以下命令安装hexo到全局 1$ npm install -g hexo 然后输入命令hexo -v输入hexo的版本号即为安装成功 发布部署注意后面要生成公私钥完成部署打开git命令行:1234567891011121314151617cd ~/.ssh# 依次输入保存目录,密码(可以一直为空,则默认保存在.ssh目录下,密码为空)$ ssh-keygen -t rsa -C &quot;your_email@your_email.com&quot;# 在命令行copy密钥内容到剪贴板$ clip &lt; ~/.ssh/id_rsa.pub# 打开github,设置密钥Setting &gt; SSH and GPG keys &gt; New SSH key &gt; 黏贴密钥信息# git 命令行测试$ ssh -T git@github.com# 输出如下信息表示配置成功The authenticity of host &apos;github.com (192.30.255.112)&apos; can&apos;t be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;github.com,192.30.255.112&apos; (RSA) to the list of known hosts.Hi magicpose! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 别忘记CNAME文件如果使用的是自己的域名,比如blog.magicpose.com,一定要在source目录下创建CNAME文件且加入一行内容:blog.magicpose.com 常用命令介绍Hexo命令Hexo官方文档1234$ hexo new(n) //写文章$ hexo generate(g) //把文章生成页面$ hexo server(s) //启动本地服务调试$ hexo deploy(d) //部署到github 可与hexo g合并为 hexo d -g 参考资料 : hexo VS jekyll","categories":[],"tags":[]},{"title":"Publish Over SSH Plugin 配置说明","slug":"Jenkins","date":"2017-09-20T09:55:16.289Z","updated":"2017-09-21T12:51:27.847Z","comments":true,"path":"2017/09/20/Jenkins/","link":"","permalink":"http://blog.magicpose.com/2017/09/20/Jenkins/","excerpt":"","text":"说明该插件可配合在编译中或编译后将编译结果发送的远程主机,并执行脚本 1, 服务器配置 jenkins/系统管理/系统配置/Publish over SSH添加SSH Server,按照主机信息依次配置即可重点: 切记 Remote Directory 应该配置为所选登录用户可读写的目录 2, 项目配置 打开项目配置 设置Send files or execute commands over SSH Transfer Set属性:12345Source files: target//*zip #要传输的文件,从项目工作目录开始Remove prefix: target/ #去掉前缀目录,只传输文件Remote directory: develop/$&#123;JOB_NAME&#125;/build-$&#123;BUILD_NUMBER&#125; #远程目录,特别注意此目录以上一步配置的&quot;SSH Server - Remote Directory&quot; 为根目录#可以使用jinkins内置属性,时间格式.具体看配置处的说明Exec command: /mnt/hard1/server/script/hello.sh 执行远程shell脚本路径","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-09-20T06:22:37.652Z","updated":"2017-09-21T12:51:18.891Z","comments":true,"path":"2017/09/20/hello-world/","link":"","permalink":"http://blog.magicpose.com/2017/09/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}